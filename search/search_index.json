{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Operator Framework and Ansible Hands-on Workshop \u00b6 Introduction \u00b6 In this workshop you will automate the deployment of an Hello World! application to OpenShift, with an Hello World operator, implemented with Ansible . Your first simple operator will do for you the automates of the creation of : a deployment a service a route Therefor it needs to collect the application domain information Your operator will have some of the capabilities in Level 1 as you see in the image below. Note: The image resource you can find on the Operator Framework: What? page. This is the definition for Level 1 from the Operator Framework Features Installation Of The Workload Operator deploys an Operand or configures off-cluster resources Operator waits for managed resources to reach a healthy state Operator conveys readiness of application or managed resources to the user leveraging the status block of the Custom Resource Configuration Of The Workload Operator provides configuration via the spec section of the Custom Resource Operator reconciles configuration and updates to it with the status of the managed resources Objectives \u00b6 This workshop will show you how to setup a development environment and deploy your first Operator written in Ansible. Upon completing this workshop you will learn the following: Setup Ansible Operator Development Environment Create Operator Scaffolding and Custom Resource Definition (CRD/RD) Test and Debug Operators Read parameter inputs from Custom Resource Definition (CRD/RD) into Ansible facts Read and create k8s objects using the k8s Ansible Module Deploy Application Estimated time and level \u00b6 Time Level 60 min beginner to intermediate Note: The installation of all prerequistes isn't included. Prerequisites \u00b6 A fedora 30 or higher system (not a container image) with access to the Internet OpenShift 4.x Cluster environment and a cluster admin account It would be good, if you are basicly familar with ... ... Podman or Docker ... using container registries like Quay.io ... handle YAMLs ... deployments of containers to RedHat OpenShift Technology/Frameworks Used \u00b6 Ansible Operator Framework Ansible Runner Additional information: Following tools are needed to be installed on your local machine: Python Podman or Docker curl IBM Cloud CLI (depending on your cloud provider) OpenShift CLI (oc) Kubernetes CLI (kubectl) GO make 0perator SDK using Ansible Credits \u00b6 Keith Tenzer (creater of the initial version of the workshop) Ross Cruickshank (Thanks, for testing the worshop on \"IBM Cloud Open Labs\" and for your valuable feedback) Thomas S\u00fcdbr\u00f6cker Additional resources \u00b6 YouTube \"How it does work?\": Building Kubernetes Operators with the Operator Framework and Ansible (Keith Tenzer) Kubernetes Operators Explained What is Ansible? Operators on OpenShift Container Platform 4.x Operator Resources: Operator SDK Operator Hub (OpenShift operators) Operator Hub (IBM operators) Internal OperatorHub in your RedHat OpenShift cluster.","title":"Introduction"},{"location":"#operator-framework-and-ansible-hands-on-workshop","text":"","title":"Operator Framework and Ansible Hands-on Workshop"},{"location":"#introduction","text":"In this workshop you will automate the deployment of an Hello World! application to OpenShift, with an Hello World operator, implemented with Ansible . Your first simple operator will do for you the automates of the creation of : a deployment a service a route Therefor it needs to collect the application domain information Your operator will have some of the capabilities in Level 1 as you see in the image below. Note: The image resource you can find on the Operator Framework: What? page. This is the definition for Level 1 from the Operator Framework Features Installation Of The Workload Operator deploys an Operand or configures off-cluster resources Operator waits for managed resources to reach a healthy state Operator conveys readiness of application or managed resources to the user leveraging the status block of the Custom Resource Configuration Of The Workload Operator provides configuration via the spec section of the Custom Resource Operator reconciles configuration and updates to it with the status of the managed resources","title":"Introduction"},{"location":"#objectives","text":"This workshop will show you how to setup a development environment and deploy your first Operator written in Ansible. Upon completing this workshop you will learn the following: Setup Ansible Operator Development Environment Create Operator Scaffolding and Custom Resource Definition (CRD/RD) Test and Debug Operators Read parameter inputs from Custom Resource Definition (CRD/RD) into Ansible facts Read and create k8s objects using the k8s Ansible Module Deploy Application","title":"Objectives"},{"location":"#estimated-time-and-level","text":"Time Level 60 min beginner to intermediate Note: The installation of all prerequistes isn't included.","title":"Estimated time and level"},{"location":"#prerequisites","text":"A fedora 30 or higher system (not a container image) with access to the Internet OpenShift 4.x Cluster environment and a cluster admin account It would be good, if you are basicly familar with ... ... Podman or Docker ... using container registries like Quay.io ... handle YAMLs ... deployments of containers to RedHat OpenShift","title":"Prerequisites"},{"location":"#technologyframeworks-used","text":"Ansible Operator Framework Ansible Runner Additional information: Following tools are needed to be installed on your local machine: Python Podman or Docker curl IBM Cloud CLI (depending on your cloud provider) OpenShift CLI (oc) Kubernetes CLI (kubectl) GO make 0perator SDK using Ansible","title":"Technology/Frameworks Used"},{"location":"#credits","text":"Keith Tenzer (creater of the initial version of the workshop) Ross Cruickshank (Thanks, for testing the worshop on \"IBM Cloud Open Labs\" and for your valuable feedback) Thomas S\u00fcdbr\u00f6cker","title":"Credits"},{"location":"#additional-resources","text":"YouTube \"How it does work?\": Building Kubernetes Operators with the Operator Framework and Ansible (Keith Tenzer) Kubernetes Operators Explained What is Ansible? Operators on OpenShift Container Platform 4.x Operator Resources: Operator SDK Operator Hub (OpenShift operators) Operator Hub (IBM operators) Internal OperatorHub in your RedHat OpenShift cluster.","title":"Additional resources"},{"location":"additional/additional/","text":"Additional information \u00b6 Relevant files in the Asible Operator SDK \u00b6 [PROJECT_ROOT]/watches.yaml By default it will create a single role, but you can certainly have many roles. Roles are mapped to the API endpoint of the CRD in the watches.yaml file. [PROJECT_ROOT]/roles/hello/tasks/main.yml Defining the task for the role hello. [PROJECT_ROOT]/config/samples/cache_v1_hello.yaml With this YAML file you create a custom resource in RedHat OpenShift. [PROJECT_ROOT]/config/rbac/role.yaml This role YAML file containes the permissions we need to create and modify resources in RedHat OpenShift. [PROJECT_ROOT]/config/default/kustomization.yaml This kustomization `YAML file contains the information for the container image we will create as our operator. Using Podman in the Makefile \u00b6 If you use Podman you need to edit the Makefile replace docker with podman . ... # Build the docker image docker-build : podman build . -t ${ IMG } # Push the docker image docker-push : podman push ${ IMG } ... bundle-build : podman build -f bundle.Dockerfile -t $( BUNDLE_IMG ) . ... Building a Ubuntu VirtualBox image \u00b6 Maybe this is useful when you build your own Ubunto VirtualBox image and with Podman. Understand Custom Resource definition \u00b6 For more details visit Kubernetes Documentation for Custom Resource Definitions Step 1: Set project context \u00b6 oc project default Step 2: Get pod for this project \u00b6 oc get pods Step 3: Get pod custom resource \u00b6 oc get awesome Example output: error: the server doesn ' t have a resource type \"awesome\" Step 4: Define custom resource \u00b6 Create a file called awesome-crd.yaml and past in following content. apiVersion : apiextensions.k8s.io/v1 kind : CustomResourceDefinition metadata : # name must match the spec fields below, and be in the form: <plural>.<group> name : awesomes.my.example.com spec : # group name to use for REST API: /apis/<group>/<version> group : my.example.com # list of versions supported by this CustomResourceDefinition versions : - name : v1 served : true storage : true schema : openAPIV3Schema : type : object properties : host : type : string port : type : string # either Namespaced or Cluster scope : Namespaced names : # plural name to be used in the URL: /apis/<group>/<version>/<plural> plural : awesomes # singular name to be used as an alias on the CLI and for display singular : awesome # kind is normally the CamelCased singular type. Your resource manifests use this. kind : Awesome # shortNames allow shorter string to match your resource on the CLI shortNames : - as oc create -f awesome-crd.yaml Example output: customresourcedefinition.apiextensions.k8s.io/awesomes.my.example.com created Step 5: Get existing resources \u00b6 oc get awesomes Example output: No resources found in default namespace. Step 6: Create a resource instance \u00b6 Now we use our defined custom resource. Create a file called awesome-crd-create.yaml and past in following content. apiVersion : my.example.com/v1 kind : Awesome metadata : name : my-awesome-instance spec : user : my-awesome-user oc create -f awesome-crd-create.yaml Example output: awesome.my.example.com/my-awesome-instance created Step 7: Get instance \u00b6 oc get awesomes Example output: NAME AGE my-awesome-instance 38s","title":"Relevant files in the \"Asible-Operator-SDK\", usage of \"Podman\" and \"CRD\" example"},{"location":"additional/additional/#additional-information","text":"","title":"Additional information"},{"location":"additional/additional/#relevant-files-in-the-asible-operator-sdk","text":"[PROJECT_ROOT]/watches.yaml By default it will create a single role, but you can certainly have many roles. Roles are mapped to the API endpoint of the CRD in the watches.yaml file. [PROJECT_ROOT]/roles/hello/tasks/main.yml Defining the task for the role hello. [PROJECT_ROOT]/config/samples/cache_v1_hello.yaml With this YAML file you create a custom resource in RedHat OpenShift. [PROJECT_ROOT]/config/rbac/role.yaml This role YAML file containes the permissions we need to create and modify resources in RedHat OpenShift. [PROJECT_ROOT]/config/default/kustomization.yaml This kustomization `YAML file contains the information for the container image we will create as our operator.","title":"Relevant files in the Asible Operator SDK"},{"location":"additional/additional/#using-podman-in-the-makefile","text":"If you use Podman you need to edit the Makefile replace docker with podman . ... # Build the docker image docker-build : podman build . -t ${ IMG } # Push the docker image docker-push : podman push ${ IMG } ... bundle-build : podman build -f bundle.Dockerfile -t $( BUNDLE_IMG ) . ...","title":"Using Podman in the Makefile"},{"location":"additional/additional/#building-a-ubuntu-virtualbox-image","text":"Maybe this is useful when you build your own Ubunto VirtualBox image and with Podman.","title":"Building a Ubuntu VirtualBox image"},{"location":"additional/additional/#understand-custom-resource-definition","text":"For more details visit Kubernetes Documentation for Custom Resource Definitions","title":"Understand Custom Resource definition"},{"location":"additional/additional/#step-1-set-project-context","text":"oc project default","title":"Step 1: Set project context"},{"location":"additional/additional/#step-2-get-pod-for-this-project","text":"oc get pods","title":"Step 2: Get pod for this project"},{"location":"additional/additional/#step-3-get-pod-custom-resource","text":"oc get awesome Example output: error: the server doesn ' t have a resource type \"awesome\"","title":"Step 3: Get pod custom resource"},{"location":"additional/additional/#step-4-define-custom-resource","text":"Create a file called awesome-crd.yaml and past in following content. apiVersion : apiextensions.k8s.io/v1 kind : CustomResourceDefinition metadata : # name must match the spec fields below, and be in the form: <plural>.<group> name : awesomes.my.example.com spec : # group name to use for REST API: /apis/<group>/<version> group : my.example.com # list of versions supported by this CustomResourceDefinition versions : - name : v1 served : true storage : true schema : openAPIV3Schema : type : object properties : host : type : string port : type : string # either Namespaced or Cluster scope : Namespaced names : # plural name to be used in the URL: /apis/<group>/<version>/<plural> plural : awesomes # singular name to be used as an alias on the CLI and for display singular : awesome # kind is normally the CamelCased singular type. Your resource manifests use this. kind : Awesome # shortNames allow shorter string to match your resource on the CLI shortNames : - as oc create -f awesome-crd.yaml Example output: customresourcedefinition.apiextensions.k8s.io/awesomes.my.example.com created","title":"Step 4: Define custom resource"},{"location":"additional/additional/#step-5-get-existing-resources","text":"oc get awesomes Example output: No resources found in default namespace.","title":"Step 5: Get existing resources"},{"location":"additional/additional/#step-6-create-a-resource-instance","text":"Now we use our defined custom resource. Create a file called awesome-crd-create.yaml and past in following content. apiVersion : my.example.com/v1 kind : Awesome metadata : name : my-awesome-instance spec : user : my-awesome-user oc create -f awesome-crd-create.yaml Example output: awesome.my.example.com/my-awesome-instance created","title":"Step 6: Create a resource instance"},{"location":"additional/additional/#step-7-get-instance","text":"oc get awesomes Example output: NAME AGE my-awesome-instance 38s","title":"Step 7: Get instance"},{"location":"additional/draft-additional/","text":"Additional information \u00b6 Relevant files in the Asible Operator SDK \u00b6 [PROJECT_ROOT]/watches.yaml By default it will create a single role, but you can certainly have many roles. Roles are mapped to the API endpoint of the CRD in the watches.yaml file. [PROJECT_ROOT]/roles/hello/tasks/main.yml Defining the task for the role hello. [PROJECT_ROOT]/config/samples/cache_v1_hello.yaml With this YAML file you create a custom resource in RedHat OpenShift. [PROJECT_ROOT]/config/rbac/role.yaml This role YAML file containes the permissions we need to create and modify resources in RedHat OpenShift. [PROJECT_ROOT]/config/default/kustomization.yaml This kustomization `YAML file contains the information for the container image we will create as our operator. Using Podman in the Makefile \u00b6 If you use Podman you need to edit the Makefile replace docker with podman . ... # Build the docker image docker-build : podman build . -t ${ IMG } # Push the docker image docker-push : podman push ${ IMG } ... bundle-build : podman build -f bundle.Dockerfile -t $( BUNDLE_IMG ) . ... Add created Operator to a custom catalog in your RedHat OpenShift cluster \u00b6 Documentation OLM - Managing Custom Catalogs Installing opm Step 1: Prepare to save the credentials \u00b6 REG_CREDS = ${ XDG_RUNTIME_DIR } /containers/auth.json Step 2: Logon to the RedHat Registry \u00b6 podman login registry.redhat.io Step 3: create a folder called catalog \u00b6 mkdir catalog Step 4: Change to the newly created directory \u00b6 cd catalog Step 5: Download the opm Operator Manager CLI \u00b6 oc image extract registry.redhat.io/openshift4/ose-operator-registry:v4.5 \\ -a ${ REG_CREDS } \\ --path /usr/bin/opm:. \\ --confirm Example output: error: directory . must be empty, pass --confirm to overwrite contents of directory Step 6: Verify the CLI is downloaded \u00b6 ls Example output: opm Step 7: Change the execution rights \u00b6 chmod +x ./opm Step 8: Move the CLI to the bin directory \u00b6 sudo mv ./opm /usr/local/bin/ Step 9: Verify the client CLI installation \u00b6 opm version Example output: Version: version.Version { OpmVersion: \"1.12.3\" , GitCommit: \"\" , BuildDate: \"2020-07-01T23:18:58Z\" , GoOs: \"linux\" , GoArch: \"amd64\" } Create an index image \u00b6 Step 1: Login to the Container registry with the operators we want to use \u00b6 docker login quay.io Step 2: Login to RedHat OpenShift \u00b6 oc login --token =[ YOUR_TOKEN ] --server = https:// [ YOUR_URL ] .us-south.containers.cloud.ibm.com: [ YOUR_PORT ] Step 3: Creating an index image \u00b6 Problem opm index add --bundles quay.io/tsuedbroecker/operator-helloworld:latest --tag quay.io/tsuedbroecker/operator-helloworld-catalog:latest --container-tool podman","title":"Additional information"},{"location":"additional/draft-additional/#additional-information","text":"","title":"Additional information"},{"location":"additional/draft-additional/#relevant-files-in-the-asible-operator-sdk","text":"[PROJECT_ROOT]/watches.yaml By default it will create a single role, but you can certainly have many roles. Roles are mapped to the API endpoint of the CRD in the watches.yaml file. [PROJECT_ROOT]/roles/hello/tasks/main.yml Defining the task for the role hello. [PROJECT_ROOT]/config/samples/cache_v1_hello.yaml With this YAML file you create a custom resource in RedHat OpenShift. [PROJECT_ROOT]/config/rbac/role.yaml This role YAML file containes the permissions we need to create and modify resources in RedHat OpenShift. [PROJECT_ROOT]/config/default/kustomization.yaml This kustomization `YAML file contains the information for the container image we will create as our operator.","title":"Relevant files in the Asible Operator SDK"},{"location":"additional/draft-additional/#using-podman-in-the-makefile","text":"If you use Podman you need to edit the Makefile replace docker with podman . ... # Build the docker image docker-build : podman build . -t ${ IMG } # Push the docker image docker-push : podman push ${ IMG } ... bundle-build : podman build -f bundle.Dockerfile -t $( BUNDLE_IMG ) . ...","title":"Using Podman in the Makefile"},{"location":"additional/draft-additional/#add-created-operator-to-a-custom-catalog-in-your-redhat-openshift-cluster","text":"Documentation OLM - Managing Custom Catalogs Installing opm","title":"Add created Operator to a custom catalog in your RedHat OpenShift cluster"},{"location":"additional/draft-additional/#step-1-prepare-to-save-the-credentials","text":"REG_CREDS = ${ XDG_RUNTIME_DIR } /containers/auth.json","title":"Step 1: Prepare to save the credentials"},{"location":"additional/draft-additional/#step-2-logon-to-the-redhat-registry","text":"podman login registry.redhat.io","title":"Step 2: Logon to the RedHat Registry"},{"location":"additional/draft-additional/#step-3-create-a-folder-called-catalog","text":"mkdir catalog","title":"Step 3: create a folder called catalog"},{"location":"additional/draft-additional/#step-4-change-to-the-newly-created-directory","text":"cd catalog","title":"Step 4: Change to the newly created directory"},{"location":"additional/draft-additional/#step-5-download-the-opm-operator-manager-cli","text":"oc image extract registry.redhat.io/openshift4/ose-operator-registry:v4.5 \\ -a ${ REG_CREDS } \\ --path /usr/bin/opm:. \\ --confirm Example output: error: directory . must be empty, pass --confirm to overwrite contents of directory","title":"Step 5: Download the opm Operator Manager CLI"},{"location":"additional/draft-additional/#step-6-verify-the-cli-is-downloaded","text":"ls Example output: opm","title":"Step 6: Verify the CLI is downloaded"},{"location":"additional/draft-additional/#step-7-change-the-execution-rights","text":"chmod +x ./opm","title":"Step 7:  Change the execution rights"},{"location":"additional/draft-additional/#step-8-move-the-cli-to-the-bindirectory","text":"sudo mv ./opm /usr/local/bin/","title":"Step 8:  Move the CLI to the bindirectory"},{"location":"additional/draft-additional/#step-9-verify-the-client-cli-installation","text":"opm version Example output: Version: version.Version { OpmVersion: \"1.12.3\" , GitCommit: \"\" , BuildDate: \"2020-07-01T23:18:58Z\" , GoOs: \"linux\" , GoArch: \"amd64\" }","title":"Step 9: Verify the client CLI installation"},{"location":"additional/draft-additional/#create-an-index-image","text":"","title":"Create an index image"},{"location":"additional/draft-additional/#step-1-login-to-the-container-registry-with-the-operators-we-want-to-use","text":"docker login quay.io","title":"Step 1: Login to the Container registry with the operators we want to use"},{"location":"additional/draft-additional/#step-2-login-to-redhat-openshift","text":"oc login --token =[ YOUR_TOKEN ] --server = https:// [ YOUR_URL ] .us-south.containers.cloud.ibm.com: [ YOUR_PORT ]","title":"Step 2: Login to RedHat OpenShift"},{"location":"additional/draft-additional/#step-3-creating-an-index-image","text":"Problem opm index add --bundles quay.io/tsuedbroecker/operator-helloworld:latest --tag quay.io/tsuedbroecker/operator-helloworld-catalog:latest --container-tool podman","title":"Step 3: Creating an index image"},{"location":"exercises/01-exercise/","text":"Exercise 1 \u00b6 In this exercise you will complete the following: Create Operator scaffolding in Ansible Add a simple debug print statement to the operator Ansible role Update the operator Custom Resource (CR) and add a parameter to toggle the print statement Test the operator using the ansible-runner Step 1: Open your OpenShift web console and copy the login command \u00b6 Select Copy Login Command Press Display Token Copy Log in with this token Insert in your terminal session oc login --token = 7DMj4CRxuUCzXXXXXXXXXX --server = https://XXXXX.com:30596 Verify your login Example output: Step 2: Create a new OpenShift project \u00b6 oc new-project operator-helloworld Example output: Step 3: Create Operator Scaffolding \u00b6 Using the operator-sdk, create the scaffolding for your new operator. The operator-sdk will generate an Ansible role , create a new custom resource definition (CRD) and all the necessary k8s objects to install the operator. This is a two step process. First initialize and then create API. mkdir operator-helloworld cd operator-helloworld operator-sdk init --plugins = ansible --domain = hello.example.com The image below show the created folders and files. operator-sdk create api --group cache --version v1 --kind Hello --generate-role Step 4: Create Custom Resource Definition (CRD) \u00b6 The operator-sdk will generate a Custom Resource Definition (CRD). The Custom Resource Definition (CRD) will extend the k8s API and allow users to interact with the Operator through the API. Here we will install Custom Resource Definition (CRD) in the current project operator-helloworld . make install Example output: Note: To inspect what happens during the install , just open the Makefile . nano Makefile Example output: Optional Step 4.1: Inspect the created Custom Resource Definition (CRD) in your cluster \u00b6 Open OpenShift web console and select Administration -> Custom Resource Definitions and insert hello into the search field. Press Hello and you see the details of the Custom Resource Definitions. Step 5: Add Print Task to Operator Role \u00b6 The operator framework implements Ansible roles. By default it will create a single role but you can certainly have many roles. Roles are mapped to the API endpoint of the CRD in the watches.yaml file. In this case we will be adding a print statement that will print some debug when a parameter toggle_message is set to true to the role. Open the ./watches.yaml file and inspect the content. nano watches.yaml # Use the 'create api' subcommand to add watches to this file. - version: v1 group: cache.hello.example.com kind: Hello role: hello # +kubebuilder:scaffold:watch Open the ./roles/hello/tasks/main.yml file and insert the print statement. nano roles/hello/tasks/main.yml The content to add to the main.yml --- # tasks file for hello - name: Hello World Task debug: msg: \"Hello World! I live in a namespace called {{ ansible_operator_meta.namespace }}\" when: toggle_message Step 6: Add parameter to the Operator Custom Resource \u00b6 Here we will add the toggle_message parameter to the CR. Any parameters under the CR spec are automatically visible in Ansible. This is how you get input from your users. In addition as you may have noticed you can access CR metadata using the ansible_operator_meta parameter in ansible. In the above example that is the name os the namespace. nano config/samples/cache_v1_hello.yaml Content to add to cache_v1_hello.yaml file. foo: bar will be replaced with toggle_message: true . apiVersion: cache.hello.example.com/v1 kind: Hello metadata: name: hello-sample spec: toggle_message: true Step 7: Run Operator using ansible-runner \u00b6 Now that we have implemented some tasks and our parameter we can run ther Operator locally using the ansible-runner to test it. ansible-operator run local Example output: Step 8: Create a hello custom resource \u00b6 Open another terminal and create the CR in your OpenShift cluster. Once the CR is created, the Operator will execute the Ansible role tasks and print our debug message. oc create -f config/samples/cache_v1_hello.yaml Example output second terminal: Example output first terminal: TASK [ Hello World Task ] ******************************** ok: [ localhost ] = > { \"msg\" : \"Hello World! I live in a namespace called operator-helloworld\" }","title":"Exercise 1"},{"location":"exercises/01-exercise/#exercise-1","text":"In this exercise you will complete the following: Create Operator scaffolding in Ansible Add a simple debug print statement to the operator Ansible role Update the operator Custom Resource (CR) and add a parameter to toggle the print statement Test the operator using the ansible-runner","title":"Exercise 1"},{"location":"exercises/01-exercise/#step-1-open-your-openshift-web-console-and-copy-the-login-command","text":"Select Copy Login Command Press Display Token Copy Log in with this token Insert in your terminal session oc login --token = 7DMj4CRxuUCzXXXXXXXXXX --server = https://XXXXX.com:30596 Verify your login Example output:","title":"Step 1: Open your OpenShift web console and copy the login command"},{"location":"exercises/01-exercise/#step-2-create-a-new-openshift-project","text":"oc new-project operator-helloworld Example output:","title":"Step 2: Create a new OpenShift project"},{"location":"exercises/01-exercise/#step-3-create-operator-scaffolding","text":"Using the operator-sdk, create the scaffolding for your new operator. The operator-sdk will generate an Ansible role , create a new custom resource definition (CRD) and all the necessary k8s objects to install the operator. This is a two step process. First initialize and then create API. mkdir operator-helloworld cd operator-helloworld operator-sdk init --plugins = ansible --domain = hello.example.com The image below show the created folders and files. operator-sdk create api --group cache --version v1 --kind Hello --generate-role","title":"Step 3: Create Operator Scaffolding"},{"location":"exercises/01-exercise/#step-4-create-custom-resource-definition-crd","text":"The operator-sdk will generate a Custom Resource Definition (CRD). The Custom Resource Definition (CRD) will extend the k8s API and allow users to interact with the Operator through the API. Here we will install Custom Resource Definition (CRD) in the current project operator-helloworld . make install Example output: Note: To inspect what happens during the install , just open the Makefile . nano Makefile Example output:","title":"Step 4: Create Custom Resource Definition (CRD)"},{"location":"exercises/01-exercise/#optional-step-41-inspect-the-created-custom-resource-definition-crd-in-your-cluster","text":"Open OpenShift web console and select Administration -> Custom Resource Definitions and insert hello into the search field. Press Hello and you see the details of the Custom Resource Definitions.","title":"Optional Step 4.1: Inspect the created Custom Resource Definition (CRD) in your cluster"},{"location":"exercises/01-exercise/#step-5-add-print-task-to-operator-role","text":"The operator framework implements Ansible roles. By default it will create a single role but you can certainly have many roles. Roles are mapped to the API endpoint of the CRD in the watches.yaml file. In this case we will be adding a print statement that will print some debug when a parameter toggle_message is set to true to the role. Open the ./watches.yaml file and inspect the content. nano watches.yaml # Use the 'create api' subcommand to add watches to this file. - version: v1 group: cache.hello.example.com kind: Hello role: hello # +kubebuilder:scaffold:watch Open the ./roles/hello/tasks/main.yml file and insert the print statement. nano roles/hello/tasks/main.yml The content to add to the main.yml --- # tasks file for hello - name: Hello World Task debug: msg: \"Hello World! I live in a namespace called {{ ansible_operator_meta.namespace }}\" when: toggle_message","title":"Step 5: Add Print Task to Operator Role"},{"location":"exercises/01-exercise/#step-6-add-parameter-to-the-operator-custom-resource","text":"Here we will add the toggle_message parameter to the CR. Any parameters under the CR spec are automatically visible in Ansible. This is how you get input from your users. In addition as you may have noticed you can access CR metadata using the ansible_operator_meta parameter in ansible. In the above example that is the name os the namespace. nano config/samples/cache_v1_hello.yaml Content to add to cache_v1_hello.yaml file. foo: bar will be replaced with toggle_message: true . apiVersion: cache.hello.example.com/v1 kind: Hello metadata: name: hello-sample spec: toggle_message: true","title":"Step 6: Add parameter to the Operator Custom Resource"},{"location":"exercises/01-exercise/#step-7-run-operator-using-ansible-runner","text":"Now that we have implemented some tasks and our parameter we can run ther Operator locally using the ansible-runner to test it. ansible-operator run local Example output:","title":"Step 7: Run Operator using ansible-runner"},{"location":"exercises/01-exercise/#step-8-create-a-hello-custom-resource","text":"Open another terminal and create the CR in your OpenShift cluster. Once the CR is created, the Operator will execute the Ansible role tasks and print our debug message. oc create -f config/samples/cache_v1_hello.yaml Example output second terminal: Example output first terminal: TASK [ Hello World Task ] ******************************** ok: [ localhost ] = > { \"msg\" : \"Hello World! I live in a namespace called operator-helloworld\" }","title":"Step 8: Create a hello custom resource"},{"location":"exercises/02-exercise/","text":"Exercise 2 \u00b6 In this exercise you will complete the following: Expand Ansible role to get the cluster domain name and save that in a fact Expand the Ansible role to deply a helloworld application Test the operator using the ansible-runner Deploy operator to namespace so it runs without the ansible-runner Step 1: Update Ansible role to get cluster domain name and save as a fact \u00b6 Here we will learn to use the k8s Ansible module to gather information we want to use later in our automation. In this case the cluster domain name. Append the following tasks to the Ansible role. We going to use following Asible `keywords: k8s_info set_fact debug nano roles/hello/tasks/main.yml Content to addd to the main.yml : - name: Get Application Domain from Cluster Ingress k8s_info: api_version: config.openshift.io/v1 kind: Ingress name: cluster when: application_domain is undefined register: ingress - name: Set Application Domain set_fact: application_domain: \"{{ ingress.resources[0].spec.domain }}\" when: application_domain is undefined - name: Print application domain debug: msg: \"Application domain is {{ application_domain }}\" Step 2: Run Operator using ansible-runner \u00b6 Each time Operator is started or something changes with our CRD the Ansible role will run and our changes will of course be executed. ansible-operator run local In the Example output you see the execution of the predefined tasks in the main.yml . Gathering Facts --------------------------- Ansible Task StdOut ------------------------------- TASK [ Gathering Facts ] ********************************************************* ------------------------------------------------------------------------------- { \"level\" : \"info\" , \"ts\" :1612430621.8876169, \"logger\" : \"logging_event_handler\" , \"msg\" : \"[playbook debug]\" , \"name\" : \"hello-sample\" , \"namespace\" : \"operator-helloworld\" , \"gvk\" : \"cache.hello.example.com/v1, Kind=Hello\" , \"event_type\" : \"runner_on_ok\" , \"job\" : \"3916589616287113937\" , \"EventData.TaskArgs\" : \"\" } Hello World Task --------------------------- Ansible Task StdOut ------------------------------- TASK [ Hello World Task ] ******************************** ok: [ localhost ] = > { \"msg\" : \"Hello World! I live in a namespace called operator-helloworld\" } \"level\" : \"info\" , \"ts\" :1612430621.8958986, \"logger\" : \"logging_event_handler\" , \"msg\" : \"[playbook task]\" , \"name\" : \"hello-sample\" , \"namespace\" : \"operator-helloworld\" , \"gvk\" : \"cache.hello.example.com/v1, Kind=Hello\" , \"event_type\" : \"playbook_on_task_start\" , \"job\" : \"3916589616287113937\" , \"EventData.Name\" : \"hello : Get Application Domain from Cluster Ingress\" } hello : Get Application Domain from Cluster Ingress -------------------------- Ansible Task StdOut ------------------------------- TASK [ hello : Get Application Domain from Cluster Ingress ] ********************* task path: /home/ubuntu/operator-helloworld/roles/hello/tasks/main.yml:8 \"level\" : \"info\" , \"ts\" :1612430622.4394364, \"logger\" : \"proxy\" , \"msg\" : \"Skipping cache lookup\" , \"resource\" : { \"IsResourceRequest\" :false, \"Path\" : \"/version\" , \"Verb\" : \"get\" , \"APIPrefix\" : \"\" , \"APIGroup\" : \"\" , \"APIVersion\" : \"\" , \"Namespace\" : \"\" , \"Resource\" : \"\" , \"Subresource\" : \"\" , \"Name\" : \"\" , \"Parts\" :null }} .... Print application domain --------------------------- Ansible Task StdOut ------------------------------- TASK [ Print application domain ] ******************************** ok: [ localhost ] = > { \"msg\" : \"Application domain is rh-workshop-..000.us-south.containers.appdomain.cloud\" } level \":\" info \",\" ts \":1612430626.1358507,\" logger \":\" runner \",\" msg \":\" Ansible-runner exited successfully \",\" job \":\" 3916589616287113937 \",\" name \":\" hello-sample \",\" namespace \":\" operator-helloworld \"} PLAY RECAP --------------------------- Ansible Task Status Event StdOut ----------------- PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 Step 3: Update Ansible role to deploy hellowoworld application \u00b6 Now we will learn to use the k8s Ansible module to deploy an application. We will deploy a helloworld application that prints to STDOUT . Notice the route is using the cluster domain we gathered in the previous step. In this step we will create a deployment, service and route for our helloworld application. Append the following tasks to the Ansible role. nano roles/hello/tasks/main.yml We use k8s:definition: to define the Service , Deployment and Route - name: Deploy helloworld service k8s: definition: apiVersion: v1 kind: Service metadata: namespace: \"{{ ansible_operator_meta.namespace }}\" labels: app: helloworld name: helloworld spec: ports: - port: 8080 targetPort: 8080 selector: app: helloworld name: helloworld status: loadBalancer: {} - name: Deploy helloworld app k8s: definition: kind: Deployment apiVersion: apps/v1 metadata: name: helloworld namespace: \"{{ ansible_operator_meta.namespace }}\" labels: app: helloworld spec: replicas: 1 strategy: type: RollingUpdate selector: matchLabels: app: helloworld template: metadata: labels: app: helloworld name: helloworld spec: containers: - image: openshift/hello-openshift imagePullPolicy: Always name: helloworld readinessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 60 periodSeconds: 10 timeoutSeconds: 60 livenessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 120 periodSeconds: 10 ports: - containerPort: 8080 restartPolicy: Always triggers: - type: ConfigChange - name: Deploy helloworld route k8s: definition: apiVersion: route.openshift.io/v1 kind: Route metadata: namespace: \"{{ ansible_operator_meta.namespace }}\" annotations: openshift.io/host.generated: \"true\" name: helloworld spec: host: \"hello-{{ ansible_operator_meta.namespace }}.{{application_domain}}\" to: kind: Service name: helloworld weight: 100 port: targetPort: 8080 wildcardPolicy: None Step 4: Update role permissions \u00b6 Since we are creating a service and route we need to add those permissions to the hello role, to add services so we can create them. Open the role.yaml file. (More about roles ) nano config/rbac/role.yaml Change the permissions. ## ## Rules for cache.hello.example.com/v1, Kind: Hello ## - apiGroups: - \"\" resources: - secrets - pods - pods/exec - pods/log - services verbs: - create - delete - get - list - patch - update - watch Append also routes and ingress api groups so we can also manage those objects. ## ## Rules for cache.hello.example.com/v1, Kind: Hello ## ... ... - apiGroups: - \"\" - config.openshift.io resources: - ingresses verbs: - create - delete - deletecollection - get - list - patch - update - watch - apiGroups: - \"\" - route.openshift.io resources: - routes - routes/custom-host verbs: - create - delete - deletecollection - get - list - patch - update - watch Step 5: Run Operator using ansible-runner \u00b6 This time we should see the application being deployed. A single pod should start and a service/route should be created. ansible-operator run local Step 6: Test our deployment \u00b6 To test simply use curl against the route URL. It does take a minute or so to start application. pods: oc get pods Example output: NAME READY STATUS RESTARTS AGE helloworld-f9d964dcc-jgcmn 1 /1 Running 0 70s * routes: oc get routes Example output: NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD helloworld hello-operator-helloworld.apps.xxxxx.com helloworld 8080 Invoke YOUR URL with curl or just open a browser and insert the URL $ curl http://hello-operator-helloworld.xxxxxx.com Hello OpenShift! Optional Step 7: Open the Developer perspective in your RedHat web console \u00b6 Select operator-helloworld project Select external route from the helloworld pod Verify the application in your browser","title":"Exercise 2"},{"location":"exercises/02-exercise/#exercise-2","text":"In this exercise you will complete the following: Expand Ansible role to get the cluster domain name and save that in a fact Expand the Ansible role to deply a helloworld application Test the operator using the ansible-runner Deploy operator to namespace so it runs without the ansible-runner","title":"Exercise 2"},{"location":"exercises/02-exercise/#step-1-update-ansible-role-to-get-cluster-domain-name-and-save-as-a-fact","text":"Here we will learn to use the k8s Ansible module to gather information we want to use later in our automation. In this case the cluster domain name. Append the following tasks to the Ansible role. We going to use following Asible `keywords: k8s_info set_fact debug nano roles/hello/tasks/main.yml Content to addd to the main.yml : - name: Get Application Domain from Cluster Ingress k8s_info: api_version: config.openshift.io/v1 kind: Ingress name: cluster when: application_domain is undefined register: ingress - name: Set Application Domain set_fact: application_domain: \"{{ ingress.resources[0].spec.domain }}\" when: application_domain is undefined - name: Print application domain debug: msg: \"Application domain is {{ application_domain }}\"","title":"Step 1: Update Ansible role to get cluster domain name and save as a fact"},{"location":"exercises/02-exercise/#step-2-run-operator-using-ansible-runner","text":"Each time Operator is started or something changes with our CRD the Ansible role will run and our changes will of course be executed. ansible-operator run local In the Example output you see the execution of the predefined tasks in the main.yml . Gathering Facts --------------------------- Ansible Task StdOut ------------------------------- TASK [ Gathering Facts ] ********************************************************* ------------------------------------------------------------------------------- { \"level\" : \"info\" , \"ts\" :1612430621.8876169, \"logger\" : \"logging_event_handler\" , \"msg\" : \"[playbook debug]\" , \"name\" : \"hello-sample\" , \"namespace\" : \"operator-helloworld\" , \"gvk\" : \"cache.hello.example.com/v1, Kind=Hello\" , \"event_type\" : \"runner_on_ok\" , \"job\" : \"3916589616287113937\" , \"EventData.TaskArgs\" : \"\" } Hello World Task --------------------------- Ansible Task StdOut ------------------------------- TASK [ Hello World Task ] ******************************** ok: [ localhost ] = > { \"msg\" : \"Hello World! I live in a namespace called operator-helloworld\" } \"level\" : \"info\" , \"ts\" :1612430621.8958986, \"logger\" : \"logging_event_handler\" , \"msg\" : \"[playbook task]\" , \"name\" : \"hello-sample\" , \"namespace\" : \"operator-helloworld\" , \"gvk\" : \"cache.hello.example.com/v1, Kind=Hello\" , \"event_type\" : \"playbook_on_task_start\" , \"job\" : \"3916589616287113937\" , \"EventData.Name\" : \"hello : Get Application Domain from Cluster Ingress\" } hello : Get Application Domain from Cluster Ingress -------------------------- Ansible Task StdOut ------------------------------- TASK [ hello : Get Application Domain from Cluster Ingress ] ********************* task path: /home/ubuntu/operator-helloworld/roles/hello/tasks/main.yml:8 \"level\" : \"info\" , \"ts\" :1612430622.4394364, \"logger\" : \"proxy\" , \"msg\" : \"Skipping cache lookup\" , \"resource\" : { \"IsResourceRequest\" :false, \"Path\" : \"/version\" , \"Verb\" : \"get\" , \"APIPrefix\" : \"\" , \"APIGroup\" : \"\" , \"APIVersion\" : \"\" , \"Namespace\" : \"\" , \"Resource\" : \"\" , \"Subresource\" : \"\" , \"Name\" : \"\" , \"Parts\" :null }} .... Print application domain --------------------------- Ansible Task StdOut ------------------------------- TASK [ Print application domain ] ******************************** ok: [ localhost ] = > { \"msg\" : \"Application domain is rh-workshop-..000.us-south.containers.appdomain.cloud\" } level \":\" info \",\" ts \":1612430626.1358507,\" logger \":\" runner \",\" msg \":\" Ansible-runner exited successfully \",\" job \":\" 3916589616287113937 \",\" name \":\" hello-sample \",\" namespace \":\" operator-helloworld \"} PLAY RECAP --------------------------- Ansible Task Status Event StdOut ----------------- PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0","title":"Step 2: Run Operator using ansible-runner"},{"location":"exercises/02-exercise/#step-3-update-ansible-role-to-deploy-hellowoworld-application","text":"Now we will learn to use the k8s Ansible module to deploy an application. We will deploy a helloworld application that prints to STDOUT . Notice the route is using the cluster domain we gathered in the previous step. In this step we will create a deployment, service and route for our helloworld application. Append the following tasks to the Ansible role. nano roles/hello/tasks/main.yml We use k8s:definition: to define the Service , Deployment and Route - name: Deploy helloworld service k8s: definition: apiVersion: v1 kind: Service metadata: namespace: \"{{ ansible_operator_meta.namespace }}\" labels: app: helloworld name: helloworld spec: ports: - port: 8080 targetPort: 8080 selector: app: helloworld name: helloworld status: loadBalancer: {} - name: Deploy helloworld app k8s: definition: kind: Deployment apiVersion: apps/v1 metadata: name: helloworld namespace: \"{{ ansible_operator_meta.namespace }}\" labels: app: helloworld spec: replicas: 1 strategy: type: RollingUpdate selector: matchLabels: app: helloworld template: metadata: labels: app: helloworld name: helloworld spec: containers: - image: openshift/hello-openshift imagePullPolicy: Always name: helloworld readinessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 60 periodSeconds: 10 timeoutSeconds: 60 livenessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 120 periodSeconds: 10 ports: - containerPort: 8080 restartPolicy: Always triggers: - type: ConfigChange - name: Deploy helloworld route k8s: definition: apiVersion: route.openshift.io/v1 kind: Route metadata: namespace: \"{{ ansible_operator_meta.namespace }}\" annotations: openshift.io/host.generated: \"true\" name: helloworld spec: host: \"hello-{{ ansible_operator_meta.namespace }}.{{application_domain}}\" to: kind: Service name: helloworld weight: 100 port: targetPort: 8080 wildcardPolicy: None","title":"Step 3: Update Ansible role to deploy hellowoworld application"},{"location":"exercises/02-exercise/#step-4-update-role-permissions","text":"Since we are creating a service and route we need to add those permissions to the hello role, to add services so we can create them. Open the role.yaml file. (More about roles ) nano config/rbac/role.yaml Change the permissions. ## ## Rules for cache.hello.example.com/v1, Kind: Hello ## - apiGroups: - \"\" resources: - secrets - pods - pods/exec - pods/log - services verbs: - create - delete - get - list - patch - update - watch Append also routes and ingress api groups so we can also manage those objects. ## ## Rules for cache.hello.example.com/v1, Kind: Hello ## ... ... - apiGroups: - \"\" - config.openshift.io resources: - ingresses verbs: - create - delete - deletecollection - get - list - patch - update - watch - apiGroups: - \"\" - route.openshift.io resources: - routes - routes/custom-host verbs: - create - delete - deletecollection - get - list - patch - update - watch","title":"Step 4: Update role permissions"},{"location":"exercises/02-exercise/#step-5-run-operator-using-ansible-runner","text":"This time we should see the application being deployed. A single pod should start and a service/route should be created. ansible-operator run local","title":"Step 5: Run Operator using ansible-runner"},{"location":"exercises/02-exercise/#step-6-test-our-deployment","text":"To test simply use curl against the route URL. It does take a minute or so to start application. pods: oc get pods Example output: NAME READY STATUS RESTARTS AGE helloworld-f9d964dcc-jgcmn 1 /1 Running 0 70s * routes: oc get routes Example output: NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD helloworld hello-operator-helloworld.apps.xxxxx.com helloworld 8080 Invoke YOUR URL with curl or just open a browser and insert the URL $ curl http://hello-operator-helloworld.xxxxxx.com Hello OpenShift!","title":"Step 6: Test our deployment"},{"location":"exercises/02-exercise/#optional-step-7-open-the-developer-perspective-in-your-redhat-web-console","text":"Select operator-helloworld project Select external route from the helloworld pod Verify the application in your browser","title":"Optional Step 7: Open the Developer perspective in your RedHat web console"},{"location":"exercises/03-exercise/","text":"Exercise 3 \u00b6 In this exercise you will complete the following: Create a Quay.io account Build image of our Operator and push it to Quay.io Deploy Operator to OpenShift cluster Preview \u00b6 Here you can see an example deployment of the HelloWorld operator we will create in this exercise, by using an existing container image from the Quay.io container registry and then we create a new HellowWorld application using the operator inside your RedHat OpenShift Cluster: Deploy operator gif: Create HelloWorld app using the operator gif: Step 1: Create Quay.io Account \u00b6 Quay.io us a container registry provided by Red Hat. You can create your own account push container images to it. Each image can be public or private. To make images available to OpenShift you will need to make them public. Go to Quay.io and create your own account if you don't have one and then login to Quay.io . docker login quay.io Step 2: Build Operator image and push to quay.io \u00b6 sudo make docker-build docker-push IMG = quay.io/ktenzer/operator-helloworld:latest Make the operator-helloworld image in your quay.io account public. Logon to quya.io, click on the image. Under `settings (on the left) there is option to make the image public. Step 3: Deploy Operator to OpenShift Cluster \u00b6 By default the operator will be deployed to a project called operator-helloworld-system . The operator is called operator-helloworld-controller-manager . make deploy IMG = quay.io/ktenzer/operator-helloworld:latest As you see in the example output, we create or configure ... ... Namespace ... Custom resource ... Leader election role ... Manager Role ... Proxy Role ... Metrixs reader ... Leader election role binding ... Manager role binding ... Proxy role binding ... Controller Manager metrics service ... Controller Manager Example output: cd config/manager && /home/ubuntu/operator-helloworld/bin/kustomize edit set image controller = quay.io/ktenzer/operator-helloworld:latest /home/ubuntu/operator-helloworld/bin/kustomize build config/default | kubectl apply -f - namespace/operator-helloworld-system created customresourcedefinition.apiextensions.k8s.io/hellos.cache.hello.example.com created role.rbac.authorization.k8s.io/operator-helloworld-leader-election-role created clusterrole.rbac.authorization.k8s.io/operator-helloworld-manager-role created clusterrole.rbac.authorization.k8s.io/operator-helloworld-metrics-reader created clusterrole.rbac.authorization.k8s.io/operator-helloworld-proxy-role created rolebinding.rbac.authorization.k8s.io/operator-helloworld-leader-election-rolebinding created clusterrolebinding.rbac.authorization.k8s.io/operator-helloworld-manager-rolebinding created clusterrolebinding.rbac.authorization.k8s.io/operator-helloworld-proxy-rolebinding created service/operator-helloworld-controller-manager-metrics-service created deployment.apps/operator-helloworld-controller-manager created Note: You can change project name by editing the config/default/kustomization.yaml file. Verify Operator Deployment oc get deployment -n operator-helloworld-system Example output: NAME READY UP-TO-DATE AVAILABLE AGE helloworld-controller-manager 1 /1 1 1 37s Optional: Open your RedHat OpenShift web console select Developer perspective and Topology . Ensure you are in the operator-helloworld-system project. Step 4: Deploy a Helloworld Application using Operator \u00b6 Using the Operator we just deployed into the operator-helloworld-system project we will now deploy the application using CR. Create the application using the operator oc create -f config/samples/cache_v1_hello.yaml -n operator-helloworld-system Get the deploment information from the project oc get deployment -n operator-helloworld-system Example output: NAME READY UP-TO-DATE AVAILABLE AGE helloworld 1/1 1 1 12m helloworld-controller-manager 1/1 1 1 12m Optional: Open your RedHat OpenShift web console select Developer perspective and Topology . Ensure you are in the operator-helloworld-system project. Optional: Open your RedHat OpenShift web console select Administrator perspective and Custom Resource Definition Search for Hello and press CRD Hello Now you see the two two created hello-sample s. One in the project operator-helloworld created the operator running on the local machine One in the project operator-helloworld-system created by the helloworld-controller-manager in the RedHat OpenShift Cluster Step 5: Cleanup Application \u00b6 Removing the CR will delete everything that was created by it since the objects are linked to the CR. oc delete hello hello-sample -n operator-helloworld-system Example output: hello.cache.hello.example.com \"hello-sample\" deleted You see there is one remaining. Step 6: Verify the operator is remaining in the deployment of the operator-helloworld-system project. \u00b6 oc get deployment -n operator-helloworld-system Example output: NAME READY UP-TO-DATE AVAILABLE AGE operator-helloworld-controller-manager 1 /1 1 1 153m Step 7: Cleanup Operator \u00b6 This will remove the Operator, CRD and all the roles. make undeploy Example output: /home/ubuntu/operator-helloworld/bin/kustomize build config/default | kubectl delete -f - namespace \"operator-helloworld-system\" deleted customresourcedefinition.apiextensions.k8s.io \"hellos.cache.hello.example.com\" deleted role.rbac.authorization.k8s.io \"operator-helloworld-leader-election-role\" deleted clusterrole.rbac.authorization.k8s.io \"operator-helloworld-manager-role\" deleted clusterrole.rbac.authorization.k8s.io \"operator-helloworld-metrics-reader\" deleted clusterrole.rbac.authorization.k8s.io \"operator-helloworld-proxy-role\" deleted rolebinding.rbac.authorization.k8s.io \"operator-helloworld-leader-election-rolebinding\" deleted clusterrolebinding.rbac.authorization.k8s.io \"operator-helloworld-manager-rolebinding\" deleted clusterrolebinding.rbac.authorization.k8s.io \"operator-helloworld-proxy-rolebinding\" deleted service \"operator-helloworld-controller-manager-metrics-service\" deleted deployment.apps \"operator-helloworld-controller-manager\" deleted Step 8: Verify the operator is deleted \u00b6 oc get deployment -n operator-helloworld-system Example output: No resources found in operator-helloworld-system namespace. You can also verify the Customer Resource Definition for hello in the web console. Congrats , if you got this far you are ready to write your own Operators in Ansible!","title":"Exercise 3"},{"location":"exercises/03-exercise/#exercise-3","text":"In this exercise you will complete the following: Create a Quay.io account Build image of our Operator and push it to Quay.io Deploy Operator to OpenShift cluster","title":"Exercise 3"},{"location":"exercises/03-exercise/#preview","text":"Here you can see an example deployment of the HelloWorld operator we will create in this exercise, by using an existing container image from the Quay.io container registry and then we create a new HellowWorld application using the operator inside your RedHat OpenShift Cluster: Deploy operator gif: Create HelloWorld app using the operator gif:","title":"Preview"},{"location":"exercises/03-exercise/#step-1-create-quayio-account","text":"Quay.io us a container registry provided by Red Hat. You can create your own account push container images to it. Each image can be public or private. To make images available to OpenShift you will need to make them public. Go to Quay.io and create your own account if you don't have one and then login to Quay.io . docker login quay.io","title":"Step 1: Create Quay.io Account"},{"location":"exercises/03-exercise/#step-2-build-operator-image-and-push-to-quayio","text":"sudo make docker-build docker-push IMG = quay.io/ktenzer/operator-helloworld:latest Make the operator-helloworld image in your quay.io account public. Logon to quya.io, click on the image. Under `settings (on the left) there is option to make the image public.","title":"Step 2: Build Operator image and push to quay.io"},{"location":"exercises/03-exercise/#step-3-deploy-operator-to-openshift-cluster","text":"By default the operator will be deployed to a project called operator-helloworld-system . The operator is called operator-helloworld-controller-manager . make deploy IMG = quay.io/ktenzer/operator-helloworld:latest As you see in the example output, we create or configure ... ... Namespace ... Custom resource ... Leader election role ... Manager Role ... Proxy Role ... Metrixs reader ... Leader election role binding ... Manager role binding ... Proxy role binding ... Controller Manager metrics service ... Controller Manager Example output: cd config/manager && /home/ubuntu/operator-helloworld/bin/kustomize edit set image controller = quay.io/ktenzer/operator-helloworld:latest /home/ubuntu/operator-helloworld/bin/kustomize build config/default | kubectl apply -f - namespace/operator-helloworld-system created customresourcedefinition.apiextensions.k8s.io/hellos.cache.hello.example.com created role.rbac.authorization.k8s.io/operator-helloworld-leader-election-role created clusterrole.rbac.authorization.k8s.io/operator-helloworld-manager-role created clusterrole.rbac.authorization.k8s.io/operator-helloworld-metrics-reader created clusterrole.rbac.authorization.k8s.io/operator-helloworld-proxy-role created rolebinding.rbac.authorization.k8s.io/operator-helloworld-leader-election-rolebinding created clusterrolebinding.rbac.authorization.k8s.io/operator-helloworld-manager-rolebinding created clusterrolebinding.rbac.authorization.k8s.io/operator-helloworld-proxy-rolebinding created service/operator-helloworld-controller-manager-metrics-service created deployment.apps/operator-helloworld-controller-manager created Note: You can change project name by editing the config/default/kustomization.yaml file. Verify Operator Deployment oc get deployment -n operator-helloworld-system Example output: NAME READY UP-TO-DATE AVAILABLE AGE helloworld-controller-manager 1 /1 1 1 37s Optional: Open your RedHat OpenShift web console select Developer perspective and Topology . Ensure you are in the operator-helloworld-system project.","title":"Step 3: Deploy Operator to OpenShift Cluster"},{"location":"exercises/03-exercise/#step-4-deploy-a-helloworld-application-using-operator","text":"Using the Operator we just deployed into the operator-helloworld-system project we will now deploy the application using CR. Create the application using the operator oc create -f config/samples/cache_v1_hello.yaml -n operator-helloworld-system Get the deploment information from the project oc get deployment -n operator-helloworld-system Example output: NAME READY UP-TO-DATE AVAILABLE AGE helloworld 1/1 1 1 12m helloworld-controller-manager 1/1 1 1 12m Optional: Open your RedHat OpenShift web console select Developer perspective and Topology . Ensure you are in the operator-helloworld-system project. Optional: Open your RedHat OpenShift web console select Administrator perspective and Custom Resource Definition Search for Hello and press CRD Hello Now you see the two two created hello-sample s. One in the project operator-helloworld created the operator running on the local machine One in the project operator-helloworld-system created by the helloworld-controller-manager in the RedHat OpenShift Cluster","title":"Step 4: Deploy a Helloworld Application using Operator"},{"location":"exercises/03-exercise/#step-5-cleanup-application","text":"Removing the CR will delete everything that was created by it since the objects are linked to the CR. oc delete hello hello-sample -n operator-helloworld-system Example output: hello.cache.hello.example.com \"hello-sample\" deleted You see there is one remaining.","title":"Step 5: Cleanup Application"},{"location":"exercises/03-exercise/#step-6-verify-the-operator-is-remaining-in-the-deployment-of-the-operator-helloworld-system-project","text":"oc get deployment -n operator-helloworld-system Example output: NAME READY UP-TO-DATE AVAILABLE AGE operator-helloworld-controller-manager 1 /1 1 1 153m","title":"Step 6: Verify the operator is remaining in the deployment of the operator-helloworld-system project."},{"location":"exercises/03-exercise/#step-7-cleanup-operator","text":"This will remove the Operator, CRD and all the roles. make undeploy Example output: /home/ubuntu/operator-helloworld/bin/kustomize build config/default | kubectl delete -f - namespace \"operator-helloworld-system\" deleted customresourcedefinition.apiextensions.k8s.io \"hellos.cache.hello.example.com\" deleted role.rbac.authorization.k8s.io \"operator-helloworld-leader-election-role\" deleted clusterrole.rbac.authorization.k8s.io \"operator-helloworld-manager-role\" deleted clusterrole.rbac.authorization.k8s.io \"operator-helloworld-metrics-reader\" deleted clusterrole.rbac.authorization.k8s.io \"operator-helloworld-proxy-role\" deleted rolebinding.rbac.authorization.k8s.io \"operator-helloworld-leader-election-rolebinding\" deleted clusterrolebinding.rbac.authorization.k8s.io \"operator-helloworld-manager-rolebinding\" deleted clusterrolebinding.rbac.authorization.k8s.io \"operator-helloworld-proxy-rolebinding\" deleted service \"operator-helloworld-controller-manager-metrics-service\" deleted deployment.apps \"operator-helloworld-controller-manager\" deleted","title":"Step 7: Cleanup Operator"},{"location":"exercises/03-exercise/#step-8-verify-the-operator-is-deleted","text":"oc get deployment -n operator-helloworld-system Example output: No resources found in operator-helloworld-system namespace. You can also verify the Customer Resource Definition for hello in the web console. Congrats , if you got this far you are ready to write your own Operators in Ansible!","title":"Step 8: Verify the operator is deleted"},{"location":"setup/01-setup/","text":"Setup Development Environment Introduction \u00b6 There are some prerequisites needed to develop and build an operator using Ansible. Also this guide and the operator-sdk assume you know Ansible roles . If you aren't yet up to speed please read about Ansible roles before proceeding. The following instructions are for fedora 30 or higher system/machine or virtual machine (not a container image) with access to the Internet.","title":"Setup Development Environment Introduction"},{"location":"setup/01-setup/#setup-development-environment-introduction","text":"There are some prerequisites needed to develop and build an operator using Ansible. Also this guide and the operator-sdk assume you know Ansible roles . If you aren't yet up to speed please read about Ansible roles before proceeding. The following instructions are for fedora 30 or higher system/machine or virtual machine (not a container image) with access to the Internet.","title":"Setup Development Environment Introduction"},{"location":"setup/02-setup-docker/","text":"Install Docker \u00b6 Step 1: Install Docker 17.03+ \u00b6 Add the docker ce repositories. Understanding DNF ) on Fedora. Note: You can also use podman and buildah instead of Docker . For example if you want to run the training on a Ubuntu machine. sudo dnf -y install dnf-plugins-core sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo Step 2: Install docker-ce \u00b6 sudo dnf -y install docker-ce docker-ce-cli sudo systemctl start docker sudo systemctl enable docker","title":"Install Docker"},{"location":"setup/02-setup-docker/#install-docker","text":"","title":"Install Docker"},{"location":"setup/02-setup-docker/#step-1-install-docker-1703","text":"Add the docker ce repositories. Understanding DNF ) on Fedora. Note: You can also use podman and buildah instead of Docker . For example if you want to run the training on a Ubuntu machine. sudo dnf -y install dnf-plugins-core sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo","title":"Step 1: Install Docker 17.03+"},{"location":"setup/02-setup-docker/#step-2-install-docker-ce","text":"sudo dnf -y install docker-ce docker-ce-cli sudo systemctl start docker sudo systemctl enable docker","title":"Step 2: Install docker-ce"},{"location":"setup/03-setup-ansibe-module-dependencies/","text":"Install Ansible and Module Dependencies \u00b6 Step 1: Install ansible \u00b6 sudo dnf -y install ansible The Ansible runner and http runner is used to run a local version of the operator. This is very useful for development and testing . pip3 install --user ansible-runner pip3 install --user ansible-runner-http Install required python modules \u00b6 pip3 install --user requests pip3 install --user openshift","title":"Install Ansible and Module Dependencies"},{"location":"setup/03-setup-ansibe-module-dependencies/#install-ansible-and-module-dependencies","text":"","title":"Install Ansible and Module Dependencies"},{"location":"setup/03-setup-ansibe-module-dependencies/#step-1-install-ansible","text":"sudo dnf -y install ansible The Ansible runner and http runner is used to run a local version of the operator. This is very useful for development and testing . pip3 install --user ansible-runner pip3 install --user ansible-runner-http","title":"Step 1: Install ansible"},{"location":"setup/03-setup-ansibe-module-dependencies/#install-required-python-modules","text":"pip3 install --user requests pip3 install --user openshift","title":"Install required python modules"},{"location":"setup/04-setup-make/","text":"Install Make utility \u00b6 sudo dnf install -y make","title":"Install Make"},{"location":"setup/04-setup-make/#install-make-utility","text":"sudo dnf install -y make","title":"Install Make utility"},{"location":"setup/05-setup-oc-cli/","text":"Install OpenShift Command Line Tools \u00b6 The OpenShift command line tools ships with oc and kubectl binaries. Download a pre-built release and install the oc as well as kubectl binaries under /usr/bin. You will need to login with your Red Hat account and select the infrastructure provider where your OpenShift cluster is running. Remember to check the permissions and ensure the binaries have execute permission. You can also download command line tools for OpenShift from the OpenShift cluster itself under the question mark by your user in the UI. Example information for RedHat OpenShift on IBM Cloud \u00b6 The access tab you see in the image contain the infromation to setup the local access to your cluster. Note: Here are example links to downloads for: RedHat OpenShift Client Versions for 4.X IBM Cloud CLI .","title":"Install OpenShift Command Line Tools"},{"location":"setup/05-setup-oc-cli/#install-openshift-command-line-tools","text":"The OpenShift command line tools ships with oc and kubectl binaries. Download a pre-built release and install the oc as well as kubectl binaries under /usr/bin. You will need to login with your Red Hat account and select the infrastructure provider where your OpenShift cluster is running. Remember to check the permissions and ensure the binaries have execute permission. You can also download command line tools for OpenShift from the OpenShift cluster itself under the question mark by your user in the UI.","title":"Install OpenShift Command Line Tools"},{"location":"setup/05-setup-oc-cli/#example-information-for-redhat-openshift-on-ibm-cloud","text":"The access tab you see in the image contain the infromation to setup the local access to your cluster. Note: Here are example links to downloads for: RedHat OpenShift Client Versions for 4.X IBM Cloud CLI .","title":"Example information for RedHat OpenShift on IBM Cloud"},{"location":"setup/06-install-operator-framework-sdk/","text":"Install Operator Framework SDK \u00b6 This workshop requires minimum v1.0.1 of the operator-sdk and ansible-operator binaries. Download a pre-built release of both binaries and install them under /usr/bin. Note: If you use brew on Ubuntu for the operator framework installation, it also worked for me :-).","title":"Install Operator Framework SDK"},{"location":"setup/06-install-operator-framework-sdk/#install-operator-framework-sdk","text":"This workshop requires minimum v1.0.1 of the operator-sdk and ansible-operator binaries. Download a pre-built release of both binaries and install them under /usr/bin. Note: If you use brew on Ubuntu for the operator framework installation, it also worked for me :-).","title":"Install Operator Framework SDK"}]}